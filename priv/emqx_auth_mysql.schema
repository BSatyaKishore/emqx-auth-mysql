%%-*- mode: erlang -*-
%% emqx_auth_mysql config mapping
{mapping, "auth.mysql.server", "emqx_auth_mysql.server", [
  {default, {"127.0.0.1", 3306}},
  {datatype, [integer, ip, string]}
]}.

{mapping, "auth.mysql.pool", "emqx_auth_mysql.server", [
  {default, 8},
  {datatype, integer}
]}.

{mapping, "auth.mysql.username", "emqx_auth_mysql.server", [
  {default, ""},
  {datatype, string}
]}.

{mapping, "auth.mysql.password", "emqx_auth_mysql.server", [
  {default, ""},
  {datatype, string}
]}.

{mapping, "auth.mysql.database", "emqx_auth_mysql.server", [
  {default, "mqtt"},
  {datatype, string}
]}.

{mapping, "auth.mysql.query_timeout", "emqx_auth_mysql.server", [
  {default, ""},
  {datatype, string}
]}.

{mapping, "auth.mysql.ssl", "emqx_auth_mysql.server", [
  {default, off},
  {datatype, flag}
]}.

{mapping, "auth.mysql.ssl.cafile", "emqx_auth_mysql.server", [
  {default, ""},
  {datatype, string}
]}.

{mapping, "auth.mysql.ssl.certfile", "emqx_auth_mysql.server", [
  {default, ""},
  {datatype, string}
]}.

{mapping, "auth.mysql.ssl.keyfile", "emqx_auth_mysql.server", [
  {default, ""},
  {datatype, string}
]}.

{translation, "emqx_auth_mysql.server", fun(Conf) ->
  ParseIp = fun(Ip) ->
      case inet:parse_address(Ip) of
          {ok, IpAddr} -> IpAddr;
          _ -> Ip
      end
  end,
  ParseHost = fun(Server) when is_binary(Server) ->
      case string:split(Server, ":", trailing) of
          [Host, Port] -> {ParseIp(Host), binary_to_integer(Port)};
          [Host] -> {ParseIp(Host), 3306}
      end
  end,
  {MyHost, MyPort} =
  case cuttlefish:conf_get("auth.mysql.server", Conf) of
    {Ip, Port} -> {ParseIp(Ip), Port};
    S          -> ParseHost(S)

  end,
  Pool = cuttlefish:conf_get("auth.mysql.pool", Conf),
  Username = cuttlefish:conf_get("auth.mysql.username", Conf),
  Passwd = cuttlefish:conf_get("auth.mysql.password", Conf),
  DB = cuttlefish:conf_get("auth.mysql.database", Conf),
  Timeout = case cuttlefish:conf_get("auth.mysql.query_timeout", Conf) of
                "" -> 300000;
                Duration ->
                    case cuttlefish_duration:parse(Duration, ms) of
                      {error, Reason} -> error(Reason);
                      Ms when is_integer(Ms) -> Ms
                  end
            end,
  Options = [{pool_size, Pool},
              {auto_reconnect, 1},
              {host, MyHost},
              {port, MyPort},
              {user, Username},
              {password, Passwd},
              {database, DB},
              {encoding, utf8},
              {query_timeout, Timeout},
              {keep_alive, true}],

  SslOpts = case cuttlefish:conf_get("auth.mysql.ssl", Conf) of
              true ->
                 CA = cuttlefish:conf_get("auth.mysql.ssl.cafile", Conf),
                 Cert = cuttlefish:conf_get("auth.mysql.ssl.certfile", Conf),
                 Key = cuttlefish:conf_get("auth.mysql.ssl.keyfile", Conf),
                    case ((Cert == "") or (Key == "")) of
                          true -> [{ssl,
                                    {server_name_indication, disable},
                                    {cacertfile, CA}}];

                          _ -> [{ssl,
                                {server_name_indication, disable},
                                {cacertfile, CA},
                                {certfile, Cert},
                                {keyfile, Key}}]
                    end;
                _ ->
                    []
  end,
  case tuple_size(MyHost) =:= 8 of
       true ->
          [{tcp_options, [inet6]} | Options] ++ SslOpts;
      _ ->
          Options ++ SslOpts
  end
end}.

{mapping, "auth.mysql.auth_query", "emqx_auth_mysql.auth_query", [
  {datatype, string}
]}.

{mapping, "auth.mysql.password_hash", "emqx_auth_mysql.password_hash", [
  {datatype, string}
]}.

{mapping, "auth.mysql.super_query", "emqx_auth_mysql.super_query", [
  {datatype, string}
]}.

{mapping, "auth.mysql.acl_query", "emqx_auth_mysql.acl_query", [
  {datatype, string}
]}.

{translation, "emqx_auth_mysql.password_hash", fun(Conf) ->
  HashValue = cuttlefish:conf_get("auth.mysql.password_hash", Conf),
    case string:tokens(HashValue, ",") of
        [Hash]           -> list_to_atom(Hash);
        [Prefix, Suffix] -> {list_to_atom(Prefix), list_to_atom(Suffix)};
        [Hash, MacFun, Iterations, Dklen] -> {list_to_atom(Hash), list_to_atom(MacFun), list_to_integer(Iterations), list_to_integer(Dklen)};
        _                -> plain
    end
end}.
